# -*- origami-fold-style: triple-braces -*-
# vim: foldmethod=marker
# Partially stolen from https://github.com/LukeSmithxyz/voidrice and my own bashrc

# Backend functions {{{
## Functions that usually aren't used only on the shell setup.

## Silently source a file, if it exists.
function source-maybe { # {{{
  while [ $# != 0 ]; do
    if [ -f "${1}" ]; then
      source "${1}"
      return 0
    else
      shift
    fi
  done
  return 1
}
# }}}

## If ${1} is not in ${PATH}, append to it.
## Exit codes:
## 1 => Invalid arguments;
## 2 => ${1} already exists on ${PATH};
function path-maybe { # {{{
  [ $# != 1 ] && return 1

  if [[ ":${PATH}:" == *"${1}"* ]]; then
    return 2
  else
    export PATH="${PATH:+"${PATH}:"}${1}"
  fi
}
# }}}

## Check if a tmux session is attached.
function tmux-attached { # {{{
  if [ $# = 1 ]; then
    tmux ls | grep "^${1}.*(attached)\$" &>/dev/null
  else
    echo -e '\e[1m\e[34mUsage:\e[m ${0} SESSION-NAME'
    return 1
  fi
} # }}}

## Start a tmux session or reattach to it.
function tmux-session { # {{{
  if [[ -n "$1" ]]; then
    if tmux has -t="$1" &>/dev/null; then
      tmux attach -t "$1"
    else
      tmux new-session -s "$1" \; source-file "${HOME}/.local/lib/tmux-sessions/$1.proj" \; $2
    fi
  else
    echo -e '\e[1m\e[34mUsage:\e[m ${0} SESSION-NAME <optional-command>'
  fi
} # }}}

## Get the current git branch.
function git-branch { # {{{
  local branch="$(git symbolic-ref --short -q HEAD 2>/dev/null)"
  if [ -n "${branch}" ]; then
    echo "${branch}"
  else
    return 1
  fi
} # }}}

## Sets up the tty coloring.
function setup-tty { # {{{
  echo -en "\e]P0282828" # Black
  echo -en "\e]P19D0006" # Red
  echo -en "\e]P279740E" # Green
  echo -en "\e]P3B57614" # Yellow
  echo -en "\e]P4076678" # Blue
  echo -en "\e]P58F3F71" # Magenta
  echo -en "\e]P6427B58" # Cyan
  echo -en "\e]P7FBF1C7" # White
  echo -en "\e]P832302F" # Bright Black
  echo -en "\e]P9FB4934" # Bright Red
  echo -en "\e]PAB8BB26" # Bright Green
  echo -en "\e]PBFABD2F" # Bright Yellow
  echo -en "\e]PC83A598" # Bright Blue
  echo -en "\e]PDD3869B" # Bright Magenta
  echo -en "\e]PE8EC07C" # Bright Cyan
  echo -en "\e]PFFBF1C7" # "Bright White"
  echo -en "\e[?16;2;112c" # Change cursor to block
  clear # Redraw screen
} # }}}

function exists { type "$1" >/dev/null 2>/dev/null; }

## Check if shell is interactive
function is_interactive { [[ $- == *i* ]]; }
function is_android { [ "$(uname -o)" = Android ]; }
function is_display { [ -n "${DISPLAY}" ]; }

# }}}
# Libraries and basic PATH {{{

source-maybe "${HOME}/.local/share/env.sh"
source-maybe "${HOME}/persist/local/share/zshrc.personal"

# }}}
# First Steps {{{

# is this an interactive shell?
if is_interactive; then
  # Set up SSH key server
  if [[ -x /usr/bin/keychain ]]; then
    eval "$(keychain --eval --ignore-missing ~/.ssh/id_rsa 2>/dev/null)"
  fi

    # tty coloring
    ! is_display && ! is_android && setup-tty
fi

# }}}
# Plugins and Extensions {{{

autoload -U colors && colors

# Completion
autoload -U compinit
zstyle ':completion:*' menu select
zmodload zsh/complist
compinit
_comp_options+=(globdots) # Include hidden files in autocomplete

# }}}
# Prompt {{{

[ "$(uname -o)" = "Android" ] && SHORT_PROMPT=1

if [ -n "$SHORT_PROMPT" ]; then
  PS1="%B%{$fg[green]%}[:%{$fg[magenta]%}%~%{$fg[green]%}]%{$reset_color%}%b\$ "
else
  PS1="%B%{$fg[green]%}[%{$fg[yellow]%}%n%{$fg[green]%}@%{$fg[blue]%}%M:%{$fg[magenta]%}%~%{$fg[green]%}]%{$reset_color%}%b\$ "
fi

PS2='  '
RPROMPT="%(?..%?)"

# }}}
# Vim bindings and cursor {{{

# Use vim keys in tab complete menu
bindkey -M menuselect 'h' vi-backward-char
bindkey -M menuselect 'k' vi-up-line-or-history
bindkey -M menuselect 'l' vi-forward-char
bindkey -M menuselect 'j' vi-down-line-or-history
bindkey -v '^?' backward-delete-char

# Change cursor shape for different vi modes
zle-keymap-select() { # {{{
if [[ ${KEYMAP} == vicmd ]] ||
  [[ $1 = 'block' ]]; then
  echo -ne '\e[1 q'

elif [[ ${KEYMAP} == main ]] ||
  [[ ${KEYMAP} == viins ]] ||
  [[ ${KEYMAP} = '' ]] ||
  [[ $1 = 'beam' ]]; then
  echo -ne '\e[5 q'
fi
} # }}}
zle-line-init() { # {{{
zle -K viins # initiate `vi insert` as keymap (can be removed if `bindkey -V` has been set elsewhere)
echo -ne "\e[5 q"
} # }}}

zle -N zle-keymap-select
zle -N zle-line-init

# Use beam shape cursor on startup.
echo -ne '\e[5 q'
# Use beam shape cursor for each new prompt.
preexec() { echo -ne '\e[5 q' ;}

# }}}
# Bindings {{{

# Use lf to switch directories
lfcd() { # {{{
  tmp="$(mktemp)"
  lf -last-dir-path="$tmp" "$@"
  if [ -f "$tmp" ]; then
    dir="$(cat "$tmp")"
    rm -f "$tmp"
    if [ -d "$dir" ]; then
      if [ "$dir" != "$(pwd)" ]; then
        cd "$dir"
      fi
    fi
  fi
} # }}}

# Use fzf to search history
fh() { # {{{
  print -z $( ([ -n "${ZSH_NAME}" ] && fc -l 1 || history) | fzf --no-sort --tac | sed -r 's/ *[0-9]*\*? *//' | sed -r 's/\\/\\\\/g')
} # }}}

# Actual binding
bindkey -s '^O' '\e0Di lfcd\n'
bindkey -s '^R' '\e0Di fh\n'

# }}}
# User functions {{{
## Functions that were designed to be used in the shell.

function inspect-dir { # {{{
  [ $# != 1 ] && return 1
  local dir="$(realpath -m "$1")"
  [ -r "${dir}" ] || {
    printf "Invalid directory: %s\n" "${dir}"
      return 1
  }

  echo -en '\e[2 q'
  printf "\e[38;5;11mDirectory:\e[m %s\n" "${dir}"

  while [ -z "${EXIT}" ]; do
    printf "::::: [c]d, [b]root, [n]nn, [g]it-check, [q]uit\n"
    printf '\e[38;5;11m(dir)\e[m Î»> '
    read -k1 ch
    printf "\n"

    case "${ch}" in
      c) cd "$dir"; local EXIT=1 ;;
      b) br "$dir"; local EXIT=1 ;;
      n) n "$dir"; local EXIT=1 ;;
      g) git-check "$dir" ;;
      "") clear ;;
      ) local EXIT=1 ;;
      q) local EXIT=1 ;;
      "") local EXIT=1 ;;
      $'\n') local EXIT=1 ;;
      *) echo "Invalid option: \"$ch\"." ;;
    esac
  done
} # }}}
function select-project { # {{{
  local projects="$(cd ~/projects && fd -d 1 -t d)"
  local choice="$(fzf-tmux <<<"$projects")"
  if [ -n "$choice" ]; then
    echo "${HOME}/projects/$choice"
  fi
} # }}}
function register-dirfunc { # {{{
  [ $# != 2 ] && return 1
  local commandWrapper="$(printf "%s%s() { %s %s; }" "%s" "$1" "%s" "$2")"
  for cmd in br inspect-dir; do
    [ "$cmd" = "inspect-dir" ] \
      && local wordPrefix='W' \
      || local wordPrefix='w'
    local command="$(printf "$commandWrapper" "$wordPrefix" "$cmd")"
    eval "$command"
  done
} # }}}

rl() { source "${ZDOTDIR:-"${HOME}"}/.zshrc"; }
sy() { "${DOTFILES}/sync"; }
wp() { local c="$(select-project)"; [ -n "$c" ] && br "$c"; }
gtd() { [ $# = 1 ] && grep "$(sed "s/_/:/g" <<<"TODO_")" $(find "${1}" -type f); }
n() { # {{{
  # Block nesting of nnn in subshells
  if [ -n $NNNLVL ] && [ "${NNNLVL:-0}" -ge 1 ]; then
    echo "nnn is already running"
    return
  fi

  # The default behaviour is to cd on quit (nnn checks if NNN_TMPFILE is set)
  # To cd on quit only on ^G, remove the "export" as in:
  #     NNN_TMPFILE="${XDG_CONFIG_HOME:-$HOME/.config}/nnn/.lastd"
  # NOTE: NNN_TMPFILE is fixed, should not be modified
  NNN_TMPFILE="${XDG_CONFIG_HOME:-$HOME/.config}/nnn/.lastd"

  nnn "$@"

  if [ -f "$NNN_TMPFILE" ]; then
    . "$NNN_TMPFILE"
    rm -f "$NNN_TMPFILE" > /dev/null
  fi
} # }}}

register-dirfunc d "$DOTFILES"
register-dirfunc k "$F_WIKI"
register-dirfunc docs "$F_PERSIST/docs"

# }}}
# Aliases {{{

alias ls='ls --color=auto'
alias la='ls -A'
alias du='du -shc'
alias cpsync='cp -ur'

alias p3='python3'
alias jl='julia'
alias G='git-check'
alias t='task'

exists nvim \
  && alias vi='nvim' vim='nvim' \
  || alias vi='vim'

alias vs='vi ~/sync/Syncthing/shared-notes.md'

alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# }}}
# Settings {{{

HISTFILE=~/.zhistory
HISTSIZE=SAVEHIST=10000
setopt sharehistory
setopt extendedhistory

# }}}
# Post Processing {{{

source-maybe "/usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" \
  "/usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"

source-maybe "${HOME}/.config/broot/launcher/bash/br"

# }}}
: # Assert first prompt doesn't show any non-zero return value
