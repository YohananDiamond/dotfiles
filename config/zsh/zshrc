#!/usr/bin/env zsh

if source "$(uselib std)" &>/dev/null; then
  _LIBRARY_LOADED=1
else
  _LIBRARY_LOADED=0
  printf >&2 "Couldn't load library file - this might cause many problems\n"
fi

if exists lua; then
  eval "$(lua "$DOTFILES/lib/z.lua" --init zsh enhanced once echo fzf)"
else
  printf >&2 "lua binary not found; z.lua won't be loaded.\n"
fi

# Load some other libraries
sourceIf "$XDG_CONFIG_HOME/dots/env.sh"
sourceIf ~/storage/share/zshrc.personal

# general options
setopt interactivecomments # can use '#' for comments in interactive
setopt PROMPT_SUBST # $(cmd) literals are run on $PS1/$PS2/$RPROMPT

# plugins
autoload -U colors && colors # color support
autoload -U compinit # completion support

# history config
HISTFILE="${XDG_CACHE_HOME:-$HOME/.cache}/zhistory"
HISTSIZE=SAVEHIST=100000
setopt sharehistory
setopt extendedhistory
setopt HIST_IGNORE_DUPS

# completion config
zstyle ':completion:*' menu select
zmodload zsh/complist
compinit
_comp_options+=(globdots) # include hidden files in autocomplete

precmd() {
  # get current working directory
  local cwd="$(pwd)"
  if grep -q '^'"$HOME" <<<"$cwd"; then
    cwd="$(sed 's/^'"$(sed 's|/|\\/|g' <<<"$HOME")"'/~/g' <<<"$cwd")"
  fi

  # set terminal title
  setTitle "$(whoami)@$(hostname 2>/dev/null || echo "???"):$cwd"
}

# construct prompt string
isTTY && _PS1_SYMBOL="" || _PS1_SYMBOL="%F{13}❯ "
PS1='%F{13}%~%(?.. %F{10}%?) $_PS1_SYMBOL%b%F{5}'
PS2="%B%F{3}---%{$reset_color%} "
RPROMPT='%F{11}$(git-branch)'
# [ "${NNNLVL:-0}" -ge 1 ] && PS1="%B%F{3}(%F{5}n%F{3})%b $PS1"

# use vim keys in tab completion menu
bindkey -M menuselect 'h' vi-backward-char
bindkey -M menuselect 'k' vi-up-line-or-history
bindkey -M menuselect 'l' vi-forward-char
bindkey -M menuselect 'j' vi-down-line-or-history
bindkey -v '^?' backward-delete-char

# change cursor shape for different vi modes
function zle-keymap-select {
  if [ "$KEYMAP" = vicmd ] || [ "$1" = "block" ]; then
    printf '\033[1 q'
  elif [ "$KEYMAP" = main ] || [ "$KEYMAP" = viins ] \
         || [ "$KEYMAP" = '' ] || [ "$1" = 'beam' ]; then
    printf '\033[5 q'
  fi
}

function zle-line-init {
  zle -K viins # initiate `vi insert` as keymap (can be removed if `bindkey -V` has been set elsewhere)
}

zle -N zle-keymap-select
zle -N zle-line-init

fzhistory.gen() {
  { [ -n "$ZSH_NAME" ] && fc -l 1 || history 1; } \
    | sed -r 's/ *[0-9]*\*? *//' \
    | tac | fzagnostic \
    | sed -r 's \\ \\\\ g'
}

fzhistory() {
  local result=$(fzhistory.gen) || return 1
  print -z "$result"
}

# Actual binding
bindkey -s '^R' '\eSfzhistory\n'
if exists lf; then
  bindkey -s '^o' '\eSlf-and-cd\n'
elif exists nnn; then
  bindkey -s '^o' '\eSnnn-and-cd\n'
fi

bindkey -s '^P' '\e[C'

assist::find-file.gen() {
  printf "%s\n" ".."
  if [ "$1" = 1 ]; then
    fd -H
  else
    fd
  fi
}

where-to-go() {
  gen=$(fzbookdirs) || return 1
  cd "$gen"
}

lf-and-cd() {
  local tmp="$(mktemp)"
  (cd "${1:-.}" && lf -last-dir-path="$tmp" "$@")
  if [ -f "$tmp" ]; then
    dir="$(cat "$tmp")"
    rm -f "$tmp" >/dev/null
    [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && cd "$dir"
  fi

  :
}

nnn-and-cd() {
  # block nesting of nnn in subshells
  if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
    printf "%s\n" "nnn is already running"
    return 1
  fi

  export NNN_TMPFILE="${XDG_CONFIG_HOME:-$HOME/.config}/nnn/.lastd"
  nnn "$@"
  if [ -f "$NNN_TMPFILE" ]; then
    . "$NNN_TMPFILE"
    rm -f "$NNN_TMPFILE" >/dev/null
  fi

  :
}

find-file() {
  local prog choice choices hidden
  hidden=0

  if [ "$1" = "-H" ]; then
    hidden=1
    shift
  fi

  [ $# = 0 ] && set -- "${EDITOR:-vi}"
  prog="${1:-$EDITOR}"
  choice="$(assist::find-file.gen "$hidden" | fzagnostic)" || return 1

  if [ -f "$choice" ]; then
    "$@" "$choice"
  elif [ -d "$choice" ]; then
    cd "$choice"
  else
    exit 1
  fi
}

duplicate-shell() {
  case $# in
    0) nohup "$TERMINAL" &>/dev/null ;;
    1) (cd "$1" && nohup "$TERMINAL" &>/dev/null) ;;
    *) exit 1 ;;
  esac & disown
}

cd-to-file() {
  [ $# = 1 ] || exit 1
  if [ -f "$1" ]; then
    cd "$(dirname "$1")"
  elif [ -d "$1" ]; then
    cd "$1"
  else
    printf >&2 "cd-to-file: invalid file\n"
  fi
}

reload-shell() { source "${ZDOTDIR:-$HOME}/.zshrc"; }

xdb() {
  case $# in
    1)
      case "$1" in
        r|rl|reload) gen-xres | xrdb ;;
        e|ed|edit) "$EDITOR" =gen-xres \
                     && { [ "$DISPLAY" ] && xdb reload } ;;
        *) return 1 ;;
      esac
      ;;
    *) return 1 ;;
  esac
}

alias W='where-to-go' w='z -I -t .'
alias f='find-file'
alias fof='find-file openfork'
alias fcd='find-file cd-to-file'
alias d='duplicate-shell'
alias rl='reload-shell'
alias make='fparent-run Makefile run-command file-dir make'

alias ls='ls --color=auto'
alias l='ls -l'
alias la='ls -A'
alias du='du -shc'

alias p3='python3'
alias jl='julia'
alias g='git-check'
alias e='$EDITOR'
alias jpdo='LANG=ja_JP.UTF8'

alias sy='dotsync'
alias sx='start-xserver'
alias of='openfork'


exists nvim \
  && alias vi='nvim' vim='nvim' \
  || alias vi='vim'

alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

sourceIf /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
sourceIf /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh

: # Assert first prompt doesn't show any non-zero return value
