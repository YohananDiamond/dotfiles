#!/usr/bin/env lua

-- NEEDED LIBRARIES (via luarocks name): http

-- Get port from the env var, or 0, which means "pick a random one that works"
local port = os.getenv("DOTCFG_PORT") or 0
local fifo = os.getenv("DOTCFG_FIFO")
if not fifo then
    error("Please specify DOTCFG_FIFO path")
end

local fifo_fd = assert(io.open(fifo, "w"))

local http_server = require("http.server")
local http_headers = require("http.headers")

local trim = function(s)
    -- https://lua-users.org/wiki/StringTrim
    return s:gsub("^%s+", ""):gsub("%s+$", "")
end

local linesOf = function(str)
    -- https://stackoverflow.com/questions/19326368/iterate-over-lines-including-blank-lines
    local pos = 1
    return function()
        if not pos then return nil end
        local p1, p2 = string.find(str, "\r?\n", pos)
        local line
        if p1 then
            line = str:sub(pos, p1 - 1)
            pos = p2 + 1
        else
            line = str:sub(pos)
            pos = nil
        end
        return line
    end
end

local settings = {}

local commands = {
    {
        path = "/set",
        method = "POST",
        content_type = "text/plain",
        func = function(body)
            local new_settings = {}

            for line in linesOf(body) do
                local first_colon = line:find(":")
                if first_colon == nil then
                    return {400, string.format("Missing colon at line %q", line)}
                else
                    local key = trim(line:sub(1, first_colon - 1))
                    if key == "" then
                        return {400, string.format("Empty key at line %q", line)}
                    end

                    local value = line:sub(first_colon + 1)
                    new_settings[key] = value
                end

            end

            for k, v in pairs(new_settings) do
                settings[k] = v
            end

            return {200, "OK"}
        end
    },

    {
        path = "/get",
        method = "GET",
        content_type = "text/plain",
        func = function(body)
            local key = trim(body)
            if key:find(":") ~= nil then
                return {400, "Invalid key (contains a colon)"}
            else
                local value = settings[key]
                if value == nil then
                    return {400, "Unknown setting"}
                end
                return {200, value}
            end
        end
    },

    {
        path = "/clear",
        method = "POST",
        content_type = "text/plain",
        func = function(body)
            settings = {}
            return {200, "OK"}
        end
    },
}

local function reply(myserver, stream)
    local req_body = stream:get_body_as_string()
    local req_headers = assert(stream:get_headers())
    local req_method = req_headers:get(":method") or ""
    local content_type = req_headers:get("content-type") or ""
    local req_path = req_headers:get(":path") or ""

    local result = nil

    for _, command in ipairs(commands) do
        if req_path == command.path then
            if req_method ~= command.method then
                result = {400, string.format("Expected method %q, got %q", command.method, req_method)}
                break
            elseif content_type ~= command.content_type then
                result = {400, string.format("Expected Content-Type %q, got %q", command.content_type, content_type)}
                break
            end

            result = command.func(req_body)
            break
        end
    end

    -- Log request to stdout
    assert(io.stdout:write(string.format('[%s] "%s %s HTTP/%g"  "%s" "%s"\n%s\n',
        os.date("%d/%b/%Y:%H:%M:%S %z"),
        req_method,
        req_path,
        stream.connection.version,
        req_headers:get("referer") or "-",
        req_headers:get("user-agent") or "-",
        req_body
    )))

    -- Build response headers
    local res_headers = http_headers.new()
    res_headers:append(":status", tostring(result[1]))
    res_headers:append("content-type", "text/plain")
    -- Send headers to client; end the stream immediately if this was a HEAD request
    assert(stream:write_headers(res_headers, req_method == "HEAD"))
    if req_method ~= "HEAD" then
        -- Send body, ending the stream
        assert(stream:write_chunk(result[2], true))
    end
end

local myserver = assert(http_server.listen({
    host = "localhost",
    port = port,
    onstream = reply,
    onerror = function(myserver, context, op, err, errno)
        local msg = op .. " on " .. tostring(context) .. " failed"
        if err then
            msg = msg .. ": " .. tostring(err)
        end
        assert(io.stderr:write(msg, "\n"))
    end,
}))

-- Manually call :listen() so that we are bound before calling :localname()
assert(myserver:listen())
do
    local bound_port = select(3, myserver:localname())
    fifo_fd:write(tostring(bound_port), "\n")
    fifo_fd:close()
    assert(io.stderr:write(string.format("Now listening on port %d\n", bound_port)))
end
-- Start the main server loop
assert(myserver:loop())
