#!/usr/bin/env sh
# vim: fdm=marker foldmarker={,}

# an opener script based off nuke
# (https://github.com/jarun/nnn/blob/master/plugins/nuke)
# TODO: finish documentation

. ~/.local/lib/ystd.sh
depCheck termup runpage

warn() {
  local out=$(printf "$@")
  if [ -t 2 ]; then
    notify-send "$out"
  else
    printf >&2 "%s\n" "$out"
  fi
}

match() {
  local ptype="$1" pat="$2"
  shift 2

  case "$ptype" in
    mime) caseMatch "$pat" "$MIMETYPE" ;;
    ext) caseMatch "$pat" "$EXT" ;;
    url) [ "$URL_PREFIX" ] && caseMatch "$pat" "$URL_PREFIX" ;;
    *)
      printf >&2 "Invalid pattern type: %s\n" "$action"
      printf >&2 "Args: "
      printf >&2 '"%s" ' "$ptype" "$pat" "$@"
      printf >&2 "\n"
      exit 1
      ;;
  esac
}

try() {
  local action="$1"
  shift

  # special cases for first arg
  checkExists "$@" || return

  # gui <prog...>: block stdout and stderr; see the 'openfork' script for automatic dettachment
  # tty <prog...>: don't block anything - opens the program in current terminal
  # pop <prog...>: pop up a new terminal using the 'termup' script
  # fallback: starts the alt program specified in $ALT_OPENER
  case "$action" in
    gui) [ "$OPEN_GUI" ] && openGui "$@" || return ;;
    tty) [ -z "$OPEN_GUI" ] && openTty "$@" || return ;;
    pop) openPop "$@"; return ;;
    fallback) openFallback ;;
    *)
      printf >&2 "Invalid action: %s\n" "$action"
      printf >&2 "Args: "
      printf >&2 '"%s" ' "$action" "$@"
      printf >&2 "\n"
      exit 1
      ;;
  esac

  exit # exits if it matched, avoiding other attempts
}

block() {
  if match "$@"; then
    warn "Attempted to open blocked file/url %s (%s)\n" "$FILE" "$MIMETYPE"
    echo "$@"
    exit 1
  fi
}

openGui() {
  "$@" >/dev/null 2>/dev/null
}

openTty() {
  "$@"
}

openPop() {
  if [ "$OPEN_GUI" ]; then
    openGui termup "$@"
  else
    openTty "$@"
  fi
}

openFallback() {
  warn "Falling back to %s (file %s, type %s)\n" "$ALT_OPENER" "$FILE" "$MIMETYPE"
  VIA_OPEN=1 "$ALT_OPENER" "$FILE"
}

caseMatch() {
  if [ $# != 2 ]; then
    printf >&2 "Usage: %s\n" "$(basename $0) <pattern> <data>"
    return 1
  fi

  case "$2" in
    $1) return 0 ;;
    *) return 1 ;;
  esac
}

checkExists() {
  case "$1" in
    runpage) exists "$2" ;;
    *) exists "$1" ;;
  esac
}

usage() {
  cat >&2 <<EOF
Usage: $PROGNAME { <file> | <url> }
Files:
  $RULES: used to store the rules, being sourced after functions are loaded. See the (incomplete) documentation of this script for help on how to use.
Environment variables:
  OPEN_GUI: forces to open only apps in GUI mode.
  ALT_OPENER: a fallback opener; default is xdg-open
EOF
}

set -f -o noclobber -o noglob # option
IFS="$(printf '%b_' '\n')"; IFS="${IFS%_}" # protect trailing \n

PROGNAME=$(basename $0)
RULES=${XDG_CONFIG_HOME:-$HOME/.config}/dots/open-rules.sh
ALT_OPENER=${ALT_OPENER:-"xdg-open"}

FILE="$1"
FILENAME=$(basename "$FILE")
FILETYPE=$(file --dereference --brief -- "$FILE")
MIMETYPE=$(file --dereference --brief --mime-type -- "$FILE")
EXT="${FILENAME##*.}"
if [ "$EXT" ]; then
  EXT="$(printf "%s" "$EXT" | tr '[:upper:]' '[:lower:]')"
fi

if echo "$FILE" | grep -q '^\(\w*\)://.*'; then
  URL_PREFIX=$(echo "$FILE" | sed 's ^\(\w*\)://.* \1 g')
fi

if [ $# != 1 ]; then
  showHelp main
else
  if [ -z "$URL_PREFIX" ] && [ ! -e "$FILE" ]; then
    warn 'Could not open "%s": no such file or directory\n' "$FILE"
    exit 1
  fi

  if [ -e "$RULES" ]; then
    . "$RULES"
    openFallback
    exit 1
  else
    printf >&2 "Could not find rules file. Please create said file at %s." "$RULES"
    exit 1
  fi
fi
