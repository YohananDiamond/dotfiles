#!/usr/bin/env python3

import os, sys
import subprocess as sp
from typing import Tuple

XDG_CACHE_HOME = os.getenv("XDG_CACHE_HOME") or os.getenv("HOME") + "/.cache"
WINEW_RECENTF = os.getenv("WINEW_RECENTF") or (XDG_CACHE_HOME + "/winew_recentf")
TERMINAL = os.getenv("TERMINAL") or "xterm"
SHELL = os.getenv("SHELL") or "/bin/sh"

def through_term(ls):
    return [TERMINAL, "-e"] + ls

class Action:
    def run(self, terminal=False):
        raise NotImplementedError

    def repr(self) -> Tuple[str, str]:
        raise NotImplementedError

class WineAction(Action):
    def __init__(self, name, binary_path, arch=None):
        self.name = name
        self.binary_path = binary_path
        self.type_ = "win"
        self.arch = arch

    def run(self, terminal=False):
        if self.arch == "win32":
            os.environ["WINEW_ARCH"] = "32"
        elif self.arch == "win64":
            os.environ["WINEW_ARCH"] = "64"

        args = ["winew", "open", self.binary_path]
        args = through_term(args) if terminal else args
        os.execvp(args[0], args)

    def repr(self):
        return (self.type_, self.name)

class ShellAction(Action):
    def __init__(self, name, command, shell=None):
        self.name = name
        self.command = command
        self.shell = shell or SHELL
        self.type_ = "cmd"
        
    def run(self, terminal=False):
        args = [self.shell, "-c", self.command]
        args = through_term(args) if terminal else args
        os.execvp(args[0], args)

    def repr(self):
        return (self.type_, self.name)

class BinAction(Action):
    def __init__(self, binary):
        self.binary = binary
        self.type_ = "bin"

    def run(self, terminal=False):
        args = [self.binary]
        args = through_term(args) if terminal else args
        os.execvp(args[0], args)

    def repr(self):
        return (self.type_, self.binary)

class MultiargAction(Action):
    def __init__(self, name, args):
        self.name = name
        self.args = args
        self.type_ = "mta"
        
    def run(self, terminal=False):
        args = through_term(self.args) if terminal else self.args
        os.execvp(args[0], args)

    def repr(self):
        return (self.type_, self.name)

def main():
    actions = []

    pathbin_proc = sp.Popen("gen-pathbin", stdout=sp.PIPE, encoding="UTF-8")
    for line in iter(pathbin_proc.stdout.readline, ""):
        actions.append(BinAction(line.rstrip()))

    if os.path.isfile(WINEW_RECENTF):
        with open(WINEW_RECENTF, "r") as f:
            for line in f.readlines():
                line = line.rstrip()
                arch, binary = line.split(" ", maxsplit=1)

                name = binary
                if os.getenv("STORAGE"):
                    name = name.replace(os.environ["STORAGE"] + "/software", "[SOFT]")
                    name = name.replace(os.environ["STORAGE"], "[STORE]")
                name = name.replace(os.environ["HOME"], "~")

                actions.append(WineAction("(" + arch + ") " + name, binary, arch=arch))

    fzagnostic_proc = sp.Popen(
        ["fzagnostic"],
        stdout=sp.PIPE,
        stdin=sp.PIPE,
        encoding="UTF-8",
    )

    id_charsize = len(str(len(actions) - 1))
    num_format = "{}".format("{:0" + str(id_charsize) + "d}")
    for (i, action) in enumerate(actions):
        type_, name = action.repr()

        print(
            "#{} {} || {}".format(
                num_format.format(i),
                type_.upper(),
                name,
            ),
            file=fzagnostic_proc.stdin,
        )

    fzagnostic_proc.stdin.close()
    if fzagnostic_proc.wait() == 0:
        output = fzagnostic_proc.stdout.readline().rstrip()

        if output.startswith("!#"):
            # if the format is the following:
            # !#<ID>
            # then action of index ID is ran on a terminal.
            actions[int(output[2:])].run(terminal=True)
        elif output.startswith("!"):
            # if the format is the following:
            # !<SHCMD>
            # then SHCMD is ran on a terminal.
            ShellAction(None, output[1:]).run(terminal=True)
        else:
            actions[int(output[1:5])].run()

def getsize(obj):
    """Determines the size of an object.

    Taken from: https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python
    """
    import types

    from gc import get_referents
    BLACKLIST = type, types.ModuleType, types.FunctionType

    if isinstance(obj, BLACKLIST):
        raise TypeError('getsize() does not take argument of type: '+ str(type(obj)))

    seen_ids = set()
    size = 0
    objects = [obj]
    while objects:
        need_referents = []
        for obj in objects:
            if not isinstance(obj, BLACKLIST) and id(obj) not in seen_ids:
                seen_ids.add(id(obj))
                size += sys.getsizeof(obj)
                need_referents.append(obj)
        objects = get_referents(*need_referents)

    return size

if __name__ == "__main__":
    main()
