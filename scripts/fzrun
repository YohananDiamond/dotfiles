#!/usr/bin/env python3

import os, sys
import subprocess as sp
from typing import Tuple

XDG_CACHE_HOME = os.getenv("XDG_CACHE_HOME") or os.getenv("HOME") + "/.cache"
WINEW_RECENTF = os.getenv("WINEW_RECENTF") or (XDG_CACHE_HOME + "/winew_recentf")
TERMINAL = os.getenv("TERMINAL") or "xterm"
SHELL = os.getenv("SHELL") or "/bin/sh"

def through_term(ls):
    return [TERMINAL, "-e"] + ls

class Action:
    def run(self, terminal=False):
        raise NotImplementedError

    def repr(self) -> Tuple[str, str]:
        raise NotImplementedError

class WineAction(Action):
    def __init__(self, name, binary_path, arch=None):
        self.name = name
        self.binary_path = binary_path
        self.type_ = "win"
        self.arch = arch

    def run(self, terminal=False):
        if self.arch == "win32":
            os.environ["WINEW_ARCH"] = "32"
        elif self.arch == "win64":
            os.environ["WINEW_ARCH"] = "64"

        args = ["winew", "open", self.binary_path]
        args = through_term(args) if terminal else args
        os.execvp(args[0], args)

    def repr(self):
        return (self.type_, self.name)

class ShellAction(Action):
    def __init__(self, name, command, shell=None):
        self.name = name
        self.command = command
        self.shell = shell or SHELL
        self.type_ = "cmd"
        
    def run(self, terminal=False):
        args = [self.shell, "-c", self.command]
        args = through_term(args) if terminal else args
        os.execvp(args[0], args)

    def repr(self):
        return (self.type_, self.name)

class BinAction(Action):
    def __init__(self, binary):
        self.binary = binary
        self.type_ = "bin"

    def run(self, terminal=False):
        args = [self.binary]
        args = through_term(args) if terminal else args
        os.execvp(args[0], args)

    def repr(self):
        return (self.type_, self.binary)

class MultiargAction(Action):
    def __init__(self, name, args):
        self.name = name
        self.args = args
        self.type_ = "mta"
        
    def run(self, terminal=False):
        args = through_term(self.args) if terminal else self.args
        os.execvp(args[0], args)

    def repr(self):
        return (self.type_, self.name)

def main():
    actions = []

    pathbin_proc = sp.Popen("gen-pathbin", stdout=sp.PIPE, encoding="UTF-8")
    PATHBIN_EXCLUDE = {"ctags.emacs"}
    for line in iter(pathbin_proc.stdout.readline, ""):
        binary = line.rstrip()
        if binary not in PATHBIN_EXCLUDE:
            actions.append(BinAction(binary))

    if os.path.isfile(WINEW_RECENTF):
        with open(WINEW_RECENTF, "r") as f:
            for line in f.readlines():
                storage_dir = os.getenv("HOME") + "/storage"

                line = line.rstrip()
                arch, binary = line.split(" ", maxsplit=1)

                name = binary
                name = name.replace(storage_dir + "/software", "@soft")
                name = name.replace(storage_dir, "@strg")

                name = name.replace(os.environ["HOME"], "~")

                actions.append(WineAction(f"({arch}) {name}", binary, arch=arch))

    fzagnostic_proc = sp.Popen(
        ["fzagnostic"],
        stdout=sp.PIPE,
        stdin=sp.PIPE,
        encoding="UTF-8",
    )

    id_charsize = len(str(len(actions) - 1))
    num_format = "{}".format("{:0" + str(id_charsize) + "d}")
    for (i, action) in enumerate(actions):
        type_, name = action.repr()

        print(
            "#{} {} || {}".format(
                num_format.format(i),
                type_.upper(),
                name,
            ),
            file=fzagnostic_proc.stdin,
        )

    fzagnostic_proc.stdin.close()
    if fzagnostic_proc.wait() == 0:
        output = fzagnostic_proc.stdout.readline().rstrip()

        if output.startswith("#"):
            actions[int(output[1:5])].run()
        if output.startswith("!#"):
            # if the format is the following:
            # !#<ID>
            # then action of index ID is ran on a terminal.
            actions[int(output[2:])].run(terminal=True)
        elif output.startswith("!"):
            # if the format is the following:
            # !<SHCMD>
            # then SHCMD is ran on a terminal.
            ShellAction(None, output[1:]).run(terminal=True)
        else:
            print(f"Invalid command: {repr(output)}", file=sys.stderr)
            sys.exit(1)

if __name__ == "__main__":
    main()
